const { App } = require('@slack/bolt');
const fs = require('fs');
const path = require('path');

// Load environment variables
require('dotenv').config();

// Load configuration
const config = JSON.parse(fs.readFileSync(path.join(__dirname, 'config.json'), 'utf8'));

// Initialize Slack app
const app = new App({
  token: process.env.SLACK_BOT_TOKEN,
  socketMode: true,
  appToken: process.env.SLACK_APP_TOKEN,
  socketModeOptions: {
    pingInterval: 30000,  // Send ping every 30 seconds
    pongTimeout: 10000    // Wait 10 seconds for pong response
  }
});

// Global session state - only one session at a time
let activeSession = null;

// User DM states for multi-message conversations
const userDMStates = new Map();

// Session state management
class SessionManager {
  static createSession(channelId, moderatorId, questionSet, anonymous = false) {
    if (activeSession) {
      throw new Error(`Active session already exists in <#${activeSession.channelId}>`);
    }

    const questions = this.getQuestions(questionSet);
    activeSession = {
      id: `session_${Date.now()}`,
      channelId,
      moderatorId,
      questionSet,
      questions,
      anonymous,
      status: 'collecting', // collecting -> voting -> completed
      responses: new Map(), // userId -> array of responses
      totalParticipants: 0, // Will be set when session starts
      createdAt: new Date()
    };

    return activeSession;
  }

  static getSession() {
    return activeSession;
  }

  static endSession() {
    activeSession = null;
    userDMStates.clear();
  }

  static getQuestions(questionSet) {
    if (questionSet === 'custom') {
      throw new Error('Custom questions require explicit question array');
    }

    if (questionSet && config.questionSets[questionSet]) {
      return config.questionSets[questionSet];
    }

    // Default to retrospective
    return config.questionSets.retrospective;
  }

  static parseCustomQuestions(args) {
    // Extract quoted strings from args
    const questions = [];
    let current = '';
    let inQuotes = false;

    for (let i = 0; i < args.length; i++) {
      const arg = args[i];
      
      if (arg.startsWith('"') && arg.endsWith('"') && arg.length > 1) {
        questions.push(arg.slice(1, -1));
      } else if (arg.startsWith('"')) {
        current = arg.slice(1);
        inQuotes = true;
      } else if (arg.endsWith('"') && inQuotes) {
        current += ' ' + arg.slice(0, -1);
        questions.push(current);
        current = '';
        inQuotes = false;
      } else if (inQuotes) {
        current += ' ' + arg;
      }
    }

    return questions;
  }

  static getAvailableQuestionSets() {
    return Object.keys(config.questionSets);
  }

  static allResponsesCollected() {
    if (!activeSession) return false;
    
    const completedCount = activeSession.responses.size;
    return completedCount >= activeSession.totalParticipants;
  }
}

// DM conversation state management
class DMStateManager {
  static initializeUser(userId, questions) {
    userDMStates.set(userId, {
      currentQuestion: 0,
      responses: Array(questions.length).fill(null).map(() => []),
      questions,
      completed: false
    });
  }

  static getUserState(userId) {
    return userDMStates.get(userId);
  }

  static addResponse(userId, response) {
    const state = userDMStates.get(userId);
    if (!state) return false;

    state.responses[state.currentQuestion].push(response);
    return true;
  }

  static async nextQuestion(userId, client) {
    const state = userDMStates.get(userId);
    if (!state) return false;

    state.currentQuestion++;
    if (state.currentQuestion >= state.questions.length) {
      state.completed = true;
      await this.saveUserResponses(userId, client);
    }
    return true;
  }

  static restartUser(userId) {
    const state = userDMStates.get(userId);
    if (!state) return false;

    state.currentQuestion = 0;
    state.responses = Array(state.questions.length).fill(null).map(() => []);
    state.completed = false;
    return true;
  }

  static async saveUserResponses(userId, client) {
    const state = userDMStates.get(userId);
    if (!state || !activeSession) return;

    // Flatten responses into session format
    const userResponses = [];
    for (let i = 0; i < state.questions.length; i++) {
      const questionResponses = state.responses[i];
      questionResponses.forEach(response => {
        userResponses.push({
          questionIndex: i,
          question: state.questions[i],
          answer: response
        });
      });
    }

    activeSession.responses.set(userId, userResponses);
    
    // Check if all responses are collected and auto-present
    if (SessionManager.allResponsesCollected()) {
      try {
        await autoPresent(client);
      } catch (error) {
        console.error('Auto-present failed:', error);
      }
    }
  }

  static getCompletedUsers() {
    const completed = [];
    for (const [userId, state] of userDMStates) {
      if (state.completed) {
        completed.push(userId);
      }
    }
    return completed;
  }

  static getInProgressUsers() {
    const inProgress = [];
    for (const [userId, state] of userDMStates) {
      if (!state.completed && state.currentQuestion > 0) {
        inProgress.push(userId);
      }
    }
    return inProgress;
  }

  static getNotStartedUsers(allUsers) {
    const started = new Set(userDMStates.keys());
    return allUsers.filter(userId => !started.has(userId));
  }
}

// Utility functions
async function getChannelMembers(channelId) {
  try {
    const result = await app.client.conversations.members({
      token: process.env.SLACK_BOT_TOKEN,
      channel: channelId
    });
    
    if (!result.members || result.members.length === 0) {
      throw new Error('No members found in channel or bot lacks permissions');
    }
    
    // Filter out bots
    const members = [];
    for (const userId of result.members) {
      try {
        const userInfo = await app.client.users.info({
          token: process.env.SLACK_BOT_TOKEN,
          user: userId
        });
        if (!userInfo.user.is_bot && !userInfo.user.deleted) {
          members.push(userId);
        }
      } catch (error) {
        console.error(`Error getting user info for ${userId}:`, error);
        // Skip this user but continue with others
      }
    }
    
    if (members.length === 0) {
      throw new Error('No active human members found in channel');
    }
    
    return members;
  } catch (error) {
    console.error('Error getting channel members:', error);
    throw new Error(`Failed to get channel members: ${error.message}`);
  }
}

// Error handling wrapper for DM sending
async function safeSendDM(client, userId, message) {
  try {
    await client.chat.postMessage({
      channel: userId,
      ...message
    });
    return true;
  } catch (error) {
    console.error(`Failed to send DM to ${userId}:`, error);
    return false;
  }
}

// DM conversation functions
async function sendInitialDM(client, userId, session, moderatorId, channelId) {
  const introText = `üëã Hi! I'm RetroBot.

<@${moderatorId}> just started a ${session.questionSet} agenda session in <#${channelId}> and I'm here to collect your input privately.

Here's how this works:
‚Ä¢ I'll ask you ${session.questions.length} questions, one at a time
‚Ä¢ Send me your thoughts (one per message) 
‚Ä¢ Reply 'done' when finished with each question
‚Ä¢ You can skip any question by just saying 'done'
‚Ä¢ Type 'start over' anytime to restart from the beginning

Ready? Let's begin!

---

Question 1/${session.questions.length}: ${session.questions[0]}
Send me your thoughts and reply 'done' when finished.`;

  return await safeSendDM(client, userId, {
    text: introText,
    blocks: [
      {
        type: 'section',
        text: {
          type: 'mrkdwn',
          text: introText
        }
      },
      {
        type: 'actions',
        elements: [
          {
            type: 'button',
            text: {
              type: 'plain_text',
              text: 'üîÑ Start Over'
            },
            action_id: 'dm_start_over',
            value: userId
          }
        ]
      }
    ]
  });
}

async function sendQuestionDM(client, userId, questionIndex, totalQuestions, question) {
  const questionText = `Question ${questionIndex + 1}/${totalQuestions}: ${question}
Send me your thoughts and reply 'done' when finished.`;

  return await safeSendDM(client, userId, {
    text: questionText,
    blocks: [
      {
        type: 'section',
        text: {
          type: 'mrkdwn',
          text: questionText
        }
      },
      {
        type: 'actions',
        elements: [
          {
            type: 'button',
            text: {
              type: 'plain_text',
              text: 'üîÑ Start Over'
            },
            action_id: 'dm_start_over',
            value: userId
          }
        ]
      }
    ]
  });
}

async function sendCompletionDM(client, userId, responses, questions) {
  let summaryText = 'üéâ All done! Here\'s what I recorded:\n\n';
  
  for (let i = 0; i < questions.length; i++) {
    const questionResponses = responses[i];
    if (questionResponses && questionResponses.length > 0) {
      summaryText += `‚úÖ ${questions[i]}: ${questionResponses.length} answer${questionResponses.length > 1 ? 's' : ''}\n`;
      questionResponses.forEach(response => {
        summaryText += `‚Ä¢ "${response}"\n`;
      });
    } else {
      summaryText += `‚è≠Ô∏è ${questions[i]}: 0 answers (skipped)\n`;
    }
    summaryText += '\n';
  }

  summaryText += `Your responses have been submitted! Head back to <#${activeSession.channelId}> for the next steps.`;

  return await safeSendDM(client, userId, {
    text: summaryText
  });
}

// Handle DM messages
app.message(async ({ message, client }) => {
  // Only handle DM messages (not channel messages)
  if (message.channel_type !== 'im' || message.bot_id) return;

  const userId = message.user;
  const text = message.text.toLowerCase().trim();
  
  // Check if user is part of an active session
  const userState = DMStateManager.getUserState(userId);
  if (!userState) return;

  // Handle control commands
  if (text === 'start over' || text === 'restart') {
    DMStateManager.restartUser(userId);
    await sendQuestionDM(client, userId, 0, userState.questions.length, userState.questions[0]);
    return;
  }

  if (text === 'done' || text === 'next' || text === 'finished') {
    // Move to next question
    await DMStateManager.nextQuestion(userId, client);
    const updatedState = DMStateManager.getUserState(userId);
    
    if (updatedState.completed) {
      // All questions complete
      await sendCompletionDM(client, userId, updatedState.responses, updatedState.questions);
    } else {
      // Send next question
      const currentQ = updatedState.currentQuestion;
      await client.chat.postMessage({
        channel: userId,
        text: `‚úÖ Recorded ${updatedState.responses[currentQ - 1].length} answers for "${updatedState.questions[currentQ - 1]}"`
      });
      
      await sendQuestionDM(client, userId, currentQ, updatedState.questions.length, updatedState.questions[currentQ]);
    }
    return;
  }

  // Handle regular response
  if (userState.completed) {
    await client.chat.postMessage({
      channel: userId,
      text: '‚úÖ You\'ve already completed all questions. Your responses have been submitted!'
    });
    return;
  }

  // Add response to current question
  DMStateManager.addResponse(userId, message.text);
  
  // Send confirmation
  const currentResponses = userState.responses[userState.currentQuestion];
  await client.chat.postMessage({
    channel: userId,
    text: `‚úÖ Got it! (${currentResponses.length} answers so far); keep answering or type 'done' to move on`
  });
});

// Handle button interactions
app.action('dm_start_over', async ({ ack, body, client }) => {
  await ack();
  
  const userId = body.user.id;
  const userState = DMStateManager.getUserState(userId);
  
  if (userState) {
    DMStateManager.restartUser(userId);
    await sendQuestionDM(client, userId, 0, userState.questions.length, userState.questions[0]);
  }
});

// Slash command handlers
app.command('/retro', async ({ command, ack, respond, client }) => {
  await ack();

  const args = command.text.trim().split(' ').filter(arg => arg.length > 0);
  const subcommand = args[0] || '';

  try {
    switch (subcommand) {
      case 'hello':
        await handleHello(respond);
        break;
      case 'help':
        await handleHelp(respond);
        break;
      case 'start':
        await handleStart(args.slice(1), command.channel_id, command.user_id, respond, client);
        break;
      case 'status':
        await handleStatus(command.channel_id, respond, client);
        break;
      case 'present':
        await handlePresent(command.channel_id, respond, client);
        break;
      case 'summarize':
        await handleSummarize(args.slice(1), command.channel_id, respond, client);
        break;
      default:
        await respond({
          text: `‚ùå Unknown command: \`${subcommand}\`\nUse \`/retro help\` for available commands.`,
          response_type: 'ephemeral'
        });
    }
  } catch (error) {
    console.error('Error handling command:', error);
    await respond({
      text: `‚ùå ${error.message}`,
      response_type: 'ephemeral'
    });
  }
});

// Command handler functions
async function handleHello(respond) {
  await respond({
    text: 'üëã RetroBot is running!\nReady to help coordinate your team discussions.\nUse `/retro help` for available commands.',
    response_type: 'ephemeral'
  });
}

async function handleHelp(respond) {
  const availableSets = SessionManager.getAvailableQuestionSets().join(', ');
  
  await respond({
    text: `üóìÔ∏è RetroBot Commands:

\`/retro start <question-set> [--anonymous]\`
  Start a new retrospective session
  Example: \`/retro start retrospective --anonymous\`

\`/retro present\`
  Manually post responses for voting (auto-presents when all done)

\`/retro summarize [--top N]\`
  Show top-voted topics (default: top 3 per question)
  Example: \`/retro summarize --top 2\`

Available question sets: ${availableSets}
Use \`--anonymous\` flag to hide participant names`,
    response_type: 'ephemeral'
  });
}

async function handleStart(args, channelId, moderatorId, respond, client) {
  if (activeSession) {
    throw new Error(`Active agenda session already running in <#${activeSession.channelId}>\nUse commands from <#${activeSession.channelId}> or wait for it to complete.`);
  }

  // Parse arguments
  let questionSet = 'retrospective';
  let anonymous = false;
  let customQuestions = null;

  if (args.length > 0) {
    // Check for anonymous flag
    anonymous = args.includes('--anonymous');
    const filteredArgs = args.filter(arg => arg !== '--anonymous');

    if (filteredArgs.length > 0) {
      if (filteredArgs[0] === 'custom') {
        customQuestions = SessionManager.parseCustomQuestions(filteredArgs.slice(1));
        if (customQuestions.length === 0) {
          throw new Error('Custom question set requires at least one question in quotes');
        }
        questionSet = 'custom';
      } else {
        questionSet = filteredArgs[0];
        if (!SessionManager.getAvailableQuestionSets().includes(questionSet)) {
          const available = SessionManager.getAvailableQuestionSets().join(', ');
          throw new Error(`Unknown question set: '${questionSet}'\nAvailable: ${available}`);
        }
      }
    }
  }

  // Create session
  const session = SessionManager.createSession(channelId, moderatorId, questionSet, anonymous);
  if (customQuestions) {
    session.questions = customQuestions;
  }

  // Get channel members
  const members = await getChannelMembers(channelId);
  const participantCount = members.length;
  
  // Set total expected participants
  session.totalParticipants = participantCount;

  // Initialize DM states for all participants
  for (const userId of members) {
    DMStateManager.initializeUser(userId, session.questions);
  }

  // Send DMs to all participants
  let dmsSent = 0;
  const failedDMs = [];
  
  for (const userId of members) {
    const success = await sendInitialDM(client, userId, session, moderatorId, channelId);
    if (success) {
      dmsSent++;
    } else {
      failedDMs.push(userId);
      // Remove user from DM state since we couldn't reach them
      userDMStates.delete(userId);
    }
  }
  
  // Update total participants to only include those we could DM
  session.totalParticipants = dmsSent;

  // Respond to the channel
  const modeText = anonymous ? 'Anonymous üîí' : 'Named üë§';
  let responseText = `üóìÔ∏è Starting agenda session: ${questionSet}
Mode: ${modeText} | Questions: ${session.questions.length}
DMing ${participantCount} participants... ‚úÖ ${dmsSent} sent successfully`;

  if (failedDMs.length > 0) {
    responseText += `\n‚ö†Ô∏è ${failedDMs.length} DMs failed (users may have DMs disabled)`;
  }

  responseText += '\n\nResponses will be automatically presented for voting when everyone finishes.';

  await respond({
    text: responseText,
    response_type: 'in_channel'
  });
}

async function handleStatus(channelId, respond, client) {
  if (!activeSession) {
    await respond({
      text: 'üìä No active retro session\nUse `/retro start` to begin a new session.',
      response_type: 'ephemeral'
    });
    return;
  }

  // Get all channel members for the active session
  const allMembers = await getChannelMembers(activeSession.channelId);
  const completed = DMStateManager.getCompletedUsers();
  const inProgress = DMStateManager.getInProgressUsers();
  const notStarted = DMStateManager.getNotStartedUsers(allMembers);

  let statusText = `üìä Session Status: <#${activeSession.channelId}> (started by <@${activeSession.moderatorId}>)\n\n`;

  if (activeSession.status === 'collecting') {
    statusText += `üîÑ Collecting responses...
‚úÖ Completed: ${completed.length}/${allMembers.length} participants`;
    
    if (completed.length > 0) {
      const completedMentions = completed.slice(0, 5).map(id => `<@${id}>`).join(', ');
      const moreText = completed.length > 5 ? ` (+${completed.length - 5} more)` : '';
      statusText += ` (${completedMentions}${moreText})`;
    }

    statusText += `\n‚è≥ In progress: ${inProgress.length} participants`;
    statusText += `\n‚ùå Not started: ${notStarted.length} participants\n\n`;
    
    const questionList = activeSession.questions.join(' | ');
    statusText += `Questions: ${questionList}\n\n`;
    statusText += `‚û°Ô∏è Next: Responses will auto-present when all participants finish`;

  } else if (activeSession.status === 'voting') {
    // Count total responses and votes
    let totalResponses = 0;
    for (const responses of activeSession.responses.values()) {
      totalResponses += responses.length;
    }

    statusText += `üó≥Ô∏è Voting in progress...
üìù Total responses posted: ${totalResponses} topics
üëç Vote by reacting to responses with emojis

‚û°Ô∏è Next: Use \`/retro summarize\` to show top-voted items`;
  }

  await respond({
    text: statusText,
    response_type: 'ephemeral'
  });
}

async function autoPresent(client) {
  if (!activeSession || activeSession.status !== 'collecting') return;
  
  const channelId = activeSession.channelId;
  
  // Change session status
  activeSession.status = 'voting';

  // Group responses by question
  const responsesByQuestion = new Map();
  for (let i = 0; i < activeSession.questions.length; i++) {
    responsesByQuestion.set(i, []);
  }

  // Collect all responses grouped by question
  for (const [userId, userResponses] of activeSession.responses) {
    for (const response of userResponses) {
      responsesByQuestion.get(response.questionIndex).push({
        userId,
        answer: response.answer,
        question: response.question
      });
    }
  }

  // Store message timestamps for vote tracking
  activeSession.votingMessages = [];

  // Post header message
  await client.chat.postMessage({
    channel: channelId,
    text: 'üìã All responses collected! Automatically presenting for voting. React with üëç üî• üìà to vote on individual items:'
  });

  // Post each response as a separate message for individual voting
  for (let i = 0; i < activeSession.questions.length; i++) {
    const responses = responsesByQuestion.get(i);
    if (responses.length > 0) {
      // Post question header
      await client.chat.postMessage({
        channel: channelId,
        text: `**${activeSession.questions[i]}**`
      });
      
      // Post each response as separate message
      for (const response of responses) {
        const attribution = activeSession.anonymous ? '' : ` - <@${response.userId}>`;
        const result = await client.chat.postMessage({
          channel: channelId,
          text: `"${response.answer}"${attribution}`
        });
        
        // Store message info for vote counting
        activeSession.votingMessages.push({
          ts: result.ts,
          questionIndex: i,
          question: activeSession.questions[i],
          answer: response.answer,
          userId: response.userId
        });
        
        // Add initial reaction options to each response
        const reactionEmojis = ['thumbsup', 'fire', 'chart_with_upwards_trend'];
        for (const emoji of reactionEmojis) {
          try {
            await client.reactions.add({
              channel: channelId,
              timestamp: result.ts,
              name: emoji
            });
          } catch (error) {
            console.error(`Failed to add reaction ${emoji} to message ${result.ts}:`, error);
          }
        }
      }
    }
  }
}

async function handlePresent(channelId, respond, client) {
  if (!activeSession) {
    throw new Error('No active retro session. Use `/retro start` first.');
  }

  if (activeSession.channelId !== channelId) {
    throw new Error(`Active session is in <#${activeSession.channelId}>. Use commands from there.`);
  }

  if (activeSession.status !== 'collecting') {
    throw new Error('Session is not in collecting phase.');
  }

  // Change session status
  activeSession.status = 'voting';

  // Group responses by question
  const responsesByQuestion = new Map();
  for (let i = 0; i < activeSession.questions.length; i++) {
    responsesByQuestion.set(i, []);
  }

  // Collect all responses grouped by question
  for (const [userId, userResponses] of activeSession.responses) {
    for (const response of userResponses) {
      responsesByQuestion.get(response.questionIndex).push({
        userId,
        answer: response.answer,
        question: response.question
      });
    }
  }

  // Check if any responses exist
  let hasResponses = false;
  for (const responses of responsesByQuestion.values()) {
    if (responses.length > 0) {
      hasResponses = true;
      break;
    }
  }

  if (!hasResponses) {
    throw new Error('No responses collected yet. Wait for participants to reply via DM.');
  }

  // Store message timestamps for vote tracking
  activeSession.votingMessages = [];

  // Post header message
  await client.chat.postMessage({
    channel: channelId,
    text: 'üìã Responses ready for voting! React with üëç üî• üìà to vote on individual items:'
  });

  // Post each response as a separate message for individual voting
  for (let i = 0; i < activeSession.questions.length; i++) {
    const responses = responsesByQuestion.get(i);
    if (responses.length > 0) {
      // Post question header
      await client.chat.postMessage({
        channel: channelId,
        text: `**${activeSession.questions[i]}**`
      });
      
      // Post each response as separate message
      for (const response of responses) {
        const attribution = activeSession.anonymous ? '' : ` - <@${response.userId}>`;
        const result = await client.chat.postMessage({
          channel: channelId,
          text: `"${response.answer}"${attribution}`
        });
        
        // Store message info for vote counting
        activeSession.votingMessages.push({
          ts: result.ts,
          questionIndex: i,
          question: activeSession.questions[i],
          answer: response.answer,
          userId: response.userId
        });
        
        // Add initial reaction options to each response
        const reactionEmojis = ['thumbsup', 'fire', 'chart_with_upwards_trend'];
        for (const emoji of reactionEmojis) {
          try {
            await client.reactions.add({
              channel: channelId,
              timestamp: result.ts,
              name: emoji
            });
          } catch (error) {
            console.error(`Failed to add reaction ${emoji} to message ${result.ts}:`, error);
          }
        }
      }
    }
  }

  await respond({
    text: '‚úÖ Responses posted as individual messages! Team members can now vote on each item.',
    response_type: 'ephemeral'
  });
}

async function handleSummarize(args, channelId, respond, client) {
  if (!activeSession) {
    throw new Error('No active retro session. Use `/retro start` first.');
  }

  if (activeSession.channelId !== channelId) {
    throw new Error(`Active session is in <#${activeSession.channelId}>. Use commands from there.`);
  }

  if (activeSession.status !== 'voting') {
    throw new Error('Session is not in voting phase. Use `/retro present` first.');
  }

  // Parse top count argument
  let topCount = 3;
  if (args.includes('--top')) {
    const topIndex = args.indexOf('--top');
    if (topIndex + 1 < args.length) {
      const count = parseInt(args[topIndex + 1]);
      if (!isNaN(count) && count > 0) {
        topCount = count;
      }
    }
  }

  let messageText = 'üèÜ Top Voted Topics for Discussion:\n\n';

  // Get reactions from each voting message
  const votedResponses = [];
  
  for (const votingMsg of activeSession.votingMessages) {
    try {
      const reactionsResult = await client.reactions.get({
        channel: channelId,
        timestamp: votingMsg.ts
      });

      // Count reactions by type (excluding bot reactions)
      let totalVotes = 0;
      let reactionBreakdown = {};
      
      if (reactionsResult.message && reactionsResult.message.reactions) {
        for (const reaction of reactionsResult.message.reactions) {
          // Subtract 1 to exclude the bot's own reaction
          const userVotes = Math.max(0, reaction.count - 1);
          totalVotes += userVotes;
          
          if (userVotes > 0) {
            reactionBreakdown[reaction.name] = userVotes;
          }
        }
      }

      // Add this response with its vote count and breakdown
      votedResponses.push({
        questionIndex: votingMsg.questionIndex,
        question: votingMsg.question,
        answer: votingMsg.answer,
        userId: votingMsg.userId,
        votes: totalVotes,
        reactionBreakdown
      });
    } catch (error) {
      console.error('Error getting reactions for message:', votingMsg.ts, error);
      // Add with 0 votes if we can't get reactions
      votedResponses.push({
        questionIndex: votingMsg.questionIndex,
        question: votingMsg.question,
        answer: votingMsg.answer,
        userId: votingMsg.userId,
        votes: 0,
        reactionBreakdown: {}
      });
    }
  }

  // Group responses by question
  const responsesByQuestion = new Map();
  for (let i = 0; i < activeSession.questions.length; i++) {
    responsesByQuestion.set(i, []);
  }

  for (const response of votedResponses) {
    responsesByQuestion.get(response.questionIndex).push(response);
  }

  // Sort and show top responses for each question
  for (let i = 0; i < activeSession.questions.length; i++) {
    const responses = responsesByQuestion.get(i);
    if (responses.length > 0) {
      // Sort by vote count
      responses.sort((a, b) => b.votes - a.votes);
      
      messageText += `**${activeSession.questions[i]}**\n`;
      const topResponses = responses.slice(0, topCount);
      
      topResponses.forEach((response, index) => {
        const attribution = activeSession.anonymous ? '' : ` - <@${response.userId}>`;
        
        // Build reaction breakdown display
        let voteText = `(${response.votes} votes`;
        if (response.reactionBreakdown && Object.keys(response.reactionBreakdown).length > 0) {
          const breakdownParts = [];
          if (response.reactionBreakdown.thumbsup || response.reactionBreakdown['+1']) {
            breakdownParts.push(`üëç${response.reactionBreakdown.thumbsup || response.reactionBreakdown['+1']}`);
          }
          if (response.reactionBreakdown.fire) {
            breakdownParts.push(`üî•${response.reactionBreakdown.fire}`);
          }
          if (response.reactionBreakdown.chart_with_upwards_trend || response.reactionBreakdown.chart_increasing) {
            breakdownParts.push(`üìà${response.reactionBreakdown.chart_with_upwards_trend || response.reactionBreakdown.chart_increasing}`);
          }
          // Add any other reactions
          for (const [emoji, count] of Object.entries(response.reactionBreakdown)) {
            if (!['thumbsup', '+1', 'fire', 'chart_with_upwards_trend', 'chart_increasing'].includes(emoji)) {
              breakdownParts.push(`:${emoji}:${count}`);
            }
          }
          if (breakdownParts.length > 0) {
            voteText += `: ${breakdownParts.join(' ')}`;
          }
        }
        voteText += ')';
        
        messageText += `${index + 1}. "${response.answer}"${attribution} ${voteText}\n`;
      });
      messageText += '\n';
    }
  }

  messageText += '---\nüéØ Session complete! Ready for discussion.';

  await respond({
    text: messageText,
    response_type: 'in_channel'
  });

  // End the session
  SessionManager.endSession();
}

// Start the app
(async () => {
  try {
    await app.start();
    console.log('‚ö°Ô∏è RetroBot is running in Socket Mode!');
  } catch (error) {
    console.error('Failed to start RetroBot:', error);
    process.exit(1);
  }
})();